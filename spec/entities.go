// Code generated by github.com/swaggest/json-cli v1.7.7, DO NOT EDIT.

// Package spec contains JSON mapping structures.
package spec

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"regexp"
)

// AsyncAPI structure is generated from "#".
//
// AsyncAPI 1.2.0 schema.
type AsyncAPI struct {
	// The AsyncAPI specification version of this document.
	// Required.
	Asyncapi AsyncAPIAsyncapi `json:"asyncapi"`
	// General information about the API.
	// Required.
	Info Info `json:"info"`
	// The base topic to the API. Example: 'hitch'.
	// Value must match pattern: `^[^/.]`.
	BaseTopic     string                 `json:"baseTopic,omitempty"`
	Servers       []Server               `json:"servers,omitempty"`
	Topics        *Topics                `json:"topics,omitempty"`     // Relative paths to the individual topics. They must be relative to the 'baseTopic'.
	Stream        *StreamObject          `json:"stream,omitempty"`     // Stream Object.
	Events        *EventsObject          `json:"events,omitempty"`     // Events Object.
	Components    *Components            `json:"components,omitempty"` // An object to hold a set of reusable objects for different aspects of the AsyncAPI Specification.
	Tags          []Tag                  `json:"tags,omitempty"`
	Security      []map[string][]string  `json:"security,omitempty"`
	ExternalDocs  *ExternalDocs          `json:"externalDocs,omitempty"` // Information about external documentation.
	MapOfAnything map[string]interface{} `json:"-"`                      // Key must match pattern: `^x-`.
}

// WithAsyncapi sets Asyncapi value.
func (a *AsyncAPI) WithAsyncapi(val AsyncAPIAsyncapi) *AsyncAPI {
	a.Asyncapi = val
	return a
}

// WithInfo sets Info value.
func (a *AsyncAPI) WithInfo(val Info) *AsyncAPI {
	a.Info = val
	return a
}

// WithBaseTopic sets BaseTopic value.
func (a *AsyncAPI) WithBaseTopic(val string) *AsyncAPI {
	a.BaseTopic = val
	return a
}

// WithServers sets Servers value.
func (a *AsyncAPI) WithServers(val ...Server) *AsyncAPI {
	a.Servers = val
	return a
}

// WithTopics sets Topics value.
func (a *AsyncAPI) WithTopics(val Topics) *AsyncAPI {
	a.Topics = &val
	return a
}

// TopicsEns ensures returned Topics is not nil.
func (a *AsyncAPI) TopicsEns() *Topics {
	if a.Topics == nil {
		a.Topics = new(Topics)
	}

	return a.Topics
}

// WithStream sets Stream value.
func (a *AsyncAPI) WithStream(val StreamObject) *AsyncAPI {
	a.Stream = &val
	return a
}

// StreamEns ensures returned Stream is not nil.
func (a *AsyncAPI) StreamEns() *StreamObject {
	if a.Stream == nil {
		a.Stream = new(StreamObject)
	}

	return a.Stream
}

// WithEvents sets Events value.
func (a *AsyncAPI) WithEvents(val EventsObject) *AsyncAPI {
	a.Events = &val
	return a
}

// EventsEns ensures returned Events is not nil.
func (a *AsyncAPI) EventsEns() *EventsObject {
	if a.Events == nil {
		a.Events = new(EventsObject)
	}

	return a.Events
}

// WithComponents sets Components value.
func (a *AsyncAPI) WithComponents(val Components) *AsyncAPI {
	a.Components = &val
	return a
}

// ComponentsEns ensures returned Components is not nil.
func (a *AsyncAPI) ComponentsEns() *Components {
	if a.Components == nil {
		a.Components = new(Components)
	}

	return a.Components
}

// WithTags sets Tags value.
func (a *AsyncAPI) WithTags(val ...Tag) *AsyncAPI {
	a.Tags = val
	return a
}

// WithSecurity sets Security value.
func (a *AsyncAPI) WithSecurity(val ...map[string][]string) *AsyncAPI {
	a.Security = val
	return a
}

// WithExternalDocs sets ExternalDocs value.
func (a *AsyncAPI) WithExternalDocs(val ExternalDocs) *AsyncAPI {
	a.ExternalDocs = &val
	return a
}

// ExternalDocsEns ensures returned ExternalDocs is not nil.
func (a *AsyncAPI) ExternalDocsEns() *ExternalDocs {
	if a.ExternalDocs == nil {
		a.ExternalDocs = new(ExternalDocs)
	}

	return a.ExternalDocs
}

// WithMapOfAnything sets MapOfAnything value.
func (a *AsyncAPI) WithMapOfAnything(val map[string]interface{}) *AsyncAPI {
	a.MapOfAnything = val
	return a
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (a *AsyncAPI) WithMapOfAnythingItem(key string, val interface{}) *AsyncAPI {
	if a.MapOfAnything == nil {
		a.MapOfAnything = make(map[string]interface{}, 1)
	}

	a.MapOfAnything[key] = val

	return a
}

type marshalAsyncAPI AsyncAPI

var knownKeysAsyncAPI = []string{
	"asyncapi",
	"info",
	"baseTopic",
	"servers",
	"topics",
	"stream",
	"events",
	"components",
	"tags",
	"security",
	"externalDocs",
}

var requireKeysAsyncAPI = []string{
	"asyncapi",
	"info",
}

// UnmarshalJSON decodes JSON.
func (a *AsyncAPI) UnmarshalJSON(data []byte) error {
	var err error

	ma := marshalAsyncAPI(*a)

	err = json.Unmarshal(data, &ma)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range requireKeysAsyncAPI {
		if _, found := rawMap[key]; !found {
			return errors.New("required key missing: " + key)
		}
	}

	for _, key := range knownKeysAsyncAPI {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if ma.MapOfAnything == nil {
				ma.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ma.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in AsyncAPI: %v", offendingKeys)
	}

	*a = AsyncAPI(ma)

	return nil
}

// MarshalJSON encodes JSON.
func (a AsyncAPI) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalAsyncAPI(a), a.MapOfAnything)
}

// Info structure is generated from "#/definitions/info".
//
// General information about the API.
type Info struct {
	// A unique and precise title of the API.
	// Required.
	Title string `json:"title"`
	// A semantic version number of the API.
	// Required.
	Version     string `json:"version"`
	Description string `json:"description,omitempty"` // A longer description of the API. Should be different from the title. CommonMark is allowed.
	// A URL to the Terms of Service for the API. MUST be in the format of a URL.
	// Format: uri.
	TermsOfService string                 `json:"termsOfService,omitempty"`
	Contact        *Contact               `json:"contact,omitempty"` // Contact information for the owners of the API.
	License        *License               `json:"license,omitempty"`
	MapOfAnything  map[string]interface{} `json:"-"` // Key must match pattern: `^x-`.
}

// WithTitle sets Title value.
func (i *Info) WithTitle(val string) *Info {
	i.Title = val
	return i
}

// WithVersion sets Version value.
func (i *Info) WithVersion(val string) *Info {
	i.Version = val
	return i
}

// WithDescription sets Description value.
func (i *Info) WithDescription(val string) *Info {
	i.Description = val
	return i
}

// WithTermsOfService sets TermsOfService value.
func (i *Info) WithTermsOfService(val string) *Info {
	i.TermsOfService = val
	return i
}

// WithContact sets Contact value.
func (i *Info) WithContact(val Contact) *Info {
	i.Contact = &val
	return i
}

// ContactEns ensures returned Contact is not nil.
func (i *Info) ContactEns() *Contact {
	if i.Contact == nil {
		i.Contact = new(Contact)
	}

	return i.Contact
}

// WithLicense sets License value.
func (i *Info) WithLicense(val License) *Info {
	i.License = &val
	return i
}

// LicenseEns ensures returned License is not nil.
func (i *Info) LicenseEns() *License {
	if i.License == nil {
		i.License = new(License)
	}

	return i.License
}

// WithMapOfAnything sets MapOfAnything value.
func (i *Info) WithMapOfAnything(val map[string]interface{}) *Info {
	i.MapOfAnything = val
	return i
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (i *Info) WithMapOfAnythingItem(key string, val interface{}) *Info {
	if i.MapOfAnything == nil {
		i.MapOfAnything = make(map[string]interface{}, 1)
	}

	i.MapOfAnything[key] = val

	return i
}

type marshalInfo Info

var knownKeysInfo = []string{
	"title",
	"version",
	"description",
	"termsOfService",
	"contact",
	"license",
}

var requireKeysInfo = []string{
	"version",
	"title",
}

// UnmarshalJSON decodes JSON.
func (i *Info) UnmarshalJSON(data []byte) error {
	var err error

	mi := marshalInfo(*i)

	err = json.Unmarshal(data, &mi)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range requireKeysInfo {
		if _, found := rawMap[key]; !found {
			return errors.New("required key missing: " + key)
		}
	}

	for _, key := range knownKeysInfo {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mi.MapOfAnything == nil {
				mi.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mi.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in Info: %v", offendingKeys)
	}

	*i = Info(mi)

	return nil
}

// MarshalJSON encodes JSON.
func (i Info) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalInfo(i), i.MapOfAnything)
}

// Contact structure is generated from "#/definitions/contact".
//
// Contact information for the owners of the API.
type Contact struct {
	Name string `json:"name,omitempty"` // The identifying name of the contact person/organization.
	// The URL pointing to the contact information.
	// Format: uri.
	URL string `json:"url,omitempty"`
	// The email address of the contact person/organization.
	// Format: email.
	Email         string                 `json:"email,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"` // Key must match pattern: `^x-`.
}

// WithName sets Name value.
func (c *Contact) WithName(val string) *Contact {
	c.Name = val
	return c
}

// WithURL sets URL value.
func (c *Contact) WithURL(val string) *Contact {
	c.URL = val
	return c
}

// WithEmail sets Email value.
func (c *Contact) WithEmail(val string) *Contact {
	c.Email = val
	return c
}

// WithMapOfAnything sets MapOfAnything value.
func (c *Contact) WithMapOfAnything(val map[string]interface{}) *Contact {
	c.MapOfAnything = val
	return c
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (c *Contact) WithMapOfAnythingItem(key string, val interface{}) *Contact {
	if c.MapOfAnything == nil {
		c.MapOfAnything = make(map[string]interface{}, 1)
	}

	c.MapOfAnything[key] = val

	return c
}

type marshalContact Contact

var knownKeysContact = []string{
	"name",
	"url",
	"email",
}

// UnmarshalJSON decodes JSON.
func (c *Contact) UnmarshalJSON(data []byte) error {
	var err error

	mc := marshalContact(*c)

	err = json.Unmarshal(data, &mc)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysContact {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mc.MapOfAnything == nil {
				mc.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mc.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in Contact: %v", offendingKeys)
	}

	*c = Contact(mc)

	return nil
}

// MarshalJSON encodes JSON.
func (c Contact) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalContact(c), c.MapOfAnything)
}

// License structure is generated from "#/definitions/license".
type License struct {
	// The name of the license type. It's encouraged to use an OSI compatible license.
	// Required.
	Name string `json:"name"`
	// The URL pointing to the license.
	// Format: uri.
	URL           string                 `json:"url,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"` // Key must match pattern: `^x-`.
}

// WithName sets Name value.
func (l *License) WithName(val string) *License {
	l.Name = val
	return l
}

// WithURL sets URL value.
func (l *License) WithURL(val string) *License {
	l.URL = val
	return l
}

// WithMapOfAnything sets MapOfAnything value.
func (l *License) WithMapOfAnything(val map[string]interface{}) *License {
	l.MapOfAnything = val
	return l
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (l *License) WithMapOfAnythingItem(key string, val interface{}) *License {
	if l.MapOfAnything == nil {
		l.MapOfAnything = make(map[string]interface{}, 1)
	}

	l.MapOfAnything[key] = val

	return l
}

type marshalLicense License

var knownKeysLicense = []string{
	"name",
	"url",
}

var requireKeysLicense = []string{
	"name",
}

// UnmarshalJSON decodes JSON.
func (l *License) UnmarshalJSON(data []byte) error {
	var err error

	ml := marshalLicense(*l)

	err = json.Unmarshal(data, &ml)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range requireKeysLicense {
		if _, found := rawMap[key]; !found {
			return errors.New("required key missing: " + key)
		}
	}

	for _, key := range knownKeysLicense {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if ml.MapOfAnything == nil {
				ml.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ml.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in License: %v", offendingKeys)
	}

	*l = License(ml)

	return nil
}

// MarshalJSON encodes JSON.
func (l License) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalLicense(l), l.MapOfAnything)
}

// Server structure is generated from "#/definitions/server".
//
// An object representing a Server.
type Server struct {
	URL         string `json:"url"` // Required.
	Description string `json:"description,omitempty"`
	// The transfer protocol.
	// Required.
	Scheme        ServerScheme              `json:"scheme"`
	SchemeVersion string                    `json:"schemeVersion,omitempty"`
	Variables     map[string]ServerVariable `json:"variables,omitempty"`
	MapOfAnything map[string]interface{}    `json:"-"` // Key must match pattern: `^x-`.
}

// WithURL sets URL value.
func (s *Server) WithURL(val string) *Server {
	s.URL = val
	return s
}

// WithDescription sets Description value.
func (s *Server) WithDescription(val string) *Server {
	s.Description = val
	return s
}

// WithScheme sets Scheme value.
func (s *Server) WithScheme(val ServerScheme) *Server {
	s.Scheme = val
	return s
}

// WithSchemeVersion sets SchemeVersion value.
func (s *Server) WithSchemeVersion(val string) *Server {
	s.SchemeVersion = val
	return s
}

// WithVariables sets Variables value.
func (s *Server) WithVariables(val map[string]ServerVariable) *Server {
	s.Variables = val
	return s
}

// WithVariablesItem sets Variables item value.
func (s *Server) WithVariablesItem(key string, val ServerVariable) *Server {
	if s.Variables == nil {
		s.Variables = make(map[string]ServerVariable, 1)
	}

	s.Variables[key] = val

	return s
}

// WithMapOfAnything sets MapOfAnything value.
func (s *Server) WithMapOfAnything(val map[string]interface{}) *Server {
	s.MapOfAnything = val
	return s
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (s *Server) WithMapOfAnythingItem(key string, val interface{}) *Server {
	if s.MapOfAnything == nil {
		s.MapOfAnything = make(map[string]interface{}, 1)
	}

	s.MapOfAnything[key] = val

	return s
}

type marshalServer Server

var knownKeysServer = []string{
	"url",
	"description",
	"scheme",
	"schemeVersion",
	"variables",
}

var requireKeysServer = []string{
	"url",
	"scheme",
}

// UnmarshalJSON decodes JSON.
func (s *Server) UnmarshalJSON(data []byte) error {
	var err error

	ms := marshalServer(*s)

	err = json.Unmarshal(data, &ms)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range requireKeysServer {
		if _, found := rawMap[key]; !found {
			return errors.New("required key missing: " + key)
		}
	}

	for _, key := range knownKeysServer {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if ms.MapOfAnything == nil {
				ms.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ms.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in Server: %v", offendingKeys)
	}

	*s = Server(ms)

	return nil
}

// MarshalJSON encodes JSON.
func (s Server) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalServer(s), s.MapOfAnything)
}

// ServerVariable structure is generated from "#/definitions/serverVariable".
//
// An object representing a Server Variable for server URL template substitution.
type ServerVariable struct {
	Enum          []string               `json:"enum,omitempty"`
	Default       string                 `json:"default,omitempty"`
	Description   string                 `json:"description,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"` // Key must match pattern: `^x-`.
}

// WithEnum sets Enum value.
func (s *ServerVariable) WithEnum(val ...string) *ServerVariable {
	s.Enum = val
	return s
}

// WithDefault sets Default value.
func (s *ServerVariable) WithDefault(val string) *ServerVariable {
	s.Default = val
	return s
}

// WithDescription sets Description value.
func (s *ServerVariable) WithDescription(val string) *ServerVariable {
	s.Description = val
	return s
}

// WithMapOfAnything sets MapOfAnything value.
func (s *ServerVariable) WithMapOfAnything(val map[string]interface{}) *ServerVariable {
	s.MapOfAnything = val
	return s
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (s *ServerVariable) WithMapOfAnythingItem(key string, val interface{}) *ServerVariable {
	if s.MapOfAnything == nil {
		s.MapOfAnything = make(map[string]interface{}, 1)
	}

	s.MapOfAnything[key] = val

	return s
}

type marshalServerVariable ServerVariable

var knownKeysServerVariable = []string{
	"enum",
	"default",
	"description",
}

// UnmarshalJSON decodes JSON.
func (s *ServerVariable) UnmarshalJSON(data []byte) error {
	var err error

	ms := marshalServerVariable(*s)

	err = json.Unmarshal(data, &ms)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysServerVariable {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if ms.MapOfAnything == nil {
				ms.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ms.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in ServerVariable: %v", offendingKeys)
	}

	*s = ServerVariable(ms)

	return nil
}

// MarshalJSON encodes JSON.
func (s ServerVariable) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalServerVariable(s), s.MapOfAnything)
}

// Topics structure is generated from "#/definitions/topics".
//
// Relative paths to the individual topics. They must be relative to the 'baseTopic'.
type Topics struct {
	MapOfAnything        map[string]interface{} `json:"-"` // Key must match pattern: `^x-`.
	MapOfTopicItemValues map[string]TopicItem   `json:"-"` // Key must match pattern: `^[^.]`.
}

// WithMapOfAnything sets MapOfAnything value.
func (t *Topics) WithMapOfAnything(val map[string]interface{}) *Topics {
	t.MapOfAnything = val
	return t
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (t *Topics) WithMapOfAnythingItem(key string, val interface{}) *Topics {
	if t.MapOfAnything == nil {
		t.MapOfAnything = make(map[string]interface{}, 1)
	}

	t.MapOfAnything[key] = val

	return t
}

// WithMapOfTopicItemValues sets MapOfTopicItemValues value.
func (t *Topics) WithMapOfTopicItemValues(val map[string]TopicItem) *Topics {
	t.MapOfTopicItemValues = val
	return t
}

// WithMapOfTopicItemValuesItem sets MapOfTopicItemValues item value.
func (t *Topics) WithMapOfTopicItemValuesItem(key string, val TopicItem) *Topics {
	if t.MapOfTopicItemValues == nil {
		t.MapOfTopicItemValues = make(map[string]TopicItem, 1)
	}

	t.MapOfTopicItemValues[key] = val

	return t
}

// UnmarshalJSON decodes JSON.
func (t *Topics) UnmarshalJSON(data []byte) error {
	var err error

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if t.MapOfAnything == nil {
				t.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			t.MapOfAnything[key] = val
		}

		if regex.MatchString(key) {
			matched = true

			if t.MapOfTopicItemValues == nil {
				t.MapOfTopicItemValues = make(map[string]TopicItem, 1)
			}

			var val TopicItem

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			t.MapOfTopicItemValues[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in Topics: %v", offendingKeys)
	}

	return nil
}

// MarshalJSON encodes JSON.
func (t Topics) MarshalJSON() ([]byte, error) {
	return marshalUnion(t.MapOfAnything, t.MapOfTopicItemValues)
}

// TopicItem structure is generated from "#/definitions/topicItem".
type TopicItem struct {
	Ref           string                 `json:"$ref,omitempty"`
	Parameters    []Parameter            `json:"parameters,omitempty"`
	Publish       *Operation             `json:"publish,omitempty"`
	Subscribe     *Operation             `json:"subscribe,omitempty"`
	Deprecated    bool                   `json:"deprecated,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"` // Key must match pattern: `^x-`.
}

// WithRef sets Ref value.
func (t *TopicItem) WithRef(val string) *TopicItem {
	t.Ref = val
	return t
}

// WithParameters sets Parameters value.
func (t *TopicItem) WithParameters(val ...Parameter) *TopicItem {
	t.Parameters = val
	return t
}

// WithPublish sets Publish value.
func (t *TopicItem) WithPublish(val Operation) *TopicItem {
	t.Publish = &val
	return t
}

// PublishEns ensures returned Publish is not nil.
func (t *TopicItem) PublishEns() *Operation {
	if t.Publish == nil {
		t.Publish = new(Operation)
	}

	return t.Publish
}

// WithSubscribe sets Subscribe value.
func (t *TopicItem) WithSubscribe(val Operation) *TopicItem {
	t.Subscribe = &val
	return t
}

// SubscribeEns ensures returned Subscribe is not nil.
func (t *TopicItem) SubscribeEns() *Operation {
	if t.Subscribe == nil {
		t.Subscribe = new(Operation)
	}

	return t.Subscribe
}

// WithDeprecated sets Deprecated value.
func (t *TopicItem) WithDeprecated(val bool) *TopicItem {
	t.Deprecated = val
	return t
}

// WithMapOfAnything sets MapOfAnything value.
func (t *TopicItem) WithMapOfAnything(val map[string]interface{}) *TopicItem {
	t.MapOfAnything = val
	return t
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (t *TopicItem) WithMapOfAnythingItem(key string, val interface{}) *TopicItem {
	if t.MapOfAnything == nil {
		t.MapOfAnything = make(map[string]interface{}, 1)
	}

	t.MapOfAnything[key] = val

	return t
}

type marshalTopicItem TopicItem

var knownKeysTopicItem = []string{
	"$ref",
	"parameters",
	"publish",
	"subscribe",
	"deprecated",
}

// UnmarshalJSON decodes JSON.
func (t *TopicItem) UnmarshalJSON(data []byte) error {
	var err error

	mt := marshalTopicItem(*t)

	err = json.Unmarshal(data, &mt)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysTopicItem {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mt.MapOfAnything == nil {
				mt.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mt.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in TopicItem: %v", offendingKeys)
	}

	*t = TopicItem(mt)

	return nil
}

// MarshalJSON encodes JSON.
func (t TopicItem) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalTopicItem(t), t.MapOfAnything)
}

// Parameter structure is generated from "#/definitions/parameter".
type Parameter struct {
	Description   string                 `json:"description,omitempty"` // A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.
	Name          string                 `json:"name,omitempty"`        // The name of the parameter.
	Schema        map[string]interface{} `json:"schema,omitempty"`      // A deterministic version of a JSON Schema object.
	Ref           string                 `json:"$ref,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"` // Key must match pattern: `^x-`.
}

// WithDescription sets Description value.
func (p *Parameter) WithDescription(val string) *Parameter {
	p.Description = val
	return p
}

// WithName sets Name value.
func (p *Parameter) WithName(val string) *Parameter {
	p.Name = val
	return p
}

// WithSchema sets Schema value.
func (p *Parameter) WithSchema(val map[string]interface{}) *Parameter {
	p.Schema = val
	return p
}

// WithSchemaItem sets Schema item value.
func (p *Parameter) WithSchemaItem(key string, val interface{}) *Parameter {
	if p.Schema == nil {
		p.Schema = make(map[string]interface{}, 1)
	}

	p.Schema[key] = val

	return p
}

// WithRef sets Ref value.
func (p *Parameter) WithRef(val string) *Parameter {
	p.Ref = val
	return p
}

// WithMapOfAnything sets MapOfAnything value.
func (p *Parameter) WithMapOfAnything(val map[string]interface{}) *Parameter {
	p.MapOfAnything = val
	return p
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (p *Parameter) WithMapOfAnythingItem(key string, val interface{}) *Parameter {
	if p.MapOfAnything == nil {
		p.MapOfAnything = make(map[string]interface{}, 1)
	}

	p.MapOfAnything[key] = val

	return p
}

type marshalParameter Parameter

var knownKeysParameter = []string{
	"description",
	"name",
	"schema",
	"$ref",
}

// UnmarshalJSON decodes JSON.
func (p *Parameter) UnmarshalJSON(data []byte) error {
	var err error

	mp := marshalParameter(*p)

	err = json.Unmarshal(data, &mp)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysParameter {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mp.MapOfAnything == nil {
				mp.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mp.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in Parameter: %v", offendingKeys)
	}

	*p = Parameter(mp)

	return nil
}

// MarshalJSON encodes JSON.
func (p Parameter) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalParameter(p), p.MapOfAnything)
}

// Message structure is generated from "#/definitions/message".
type Message struct {
	Ref           string                 `json:"$ref,omitempty"`
	Headers       map[string]interface{} `json:"headers,omitempty"` // A deterministic version of a JSON Schema object.
	Payload       map[string]interface{} `json:"payload,omitempty"` // A deterministic version of a JSON Schema object.
	Tags          []Tag                  `json:"tags,omitempty"`
	Summary       string                 `json:"summary,omitempty"`      // A brief summary of the message.
	Description   string                 `json:"description,omitempty"`  // A longer description of the message. CommonMark is allowed.
	ExternalDocs  *ExternalDocs          `json:"externalDocs,omitempty"` // Information about external documentation.
	Deprecated    bool                   `json:"deprecated,omitempty"`
	Example       *interface{}           `json:"example,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"` // Key must match pattern: `^x-`.
}

// WithRef sets Ref value.
func (m *Message) WithRef(val string) *Message {
	m.Ref = val
	return m
}

// WithHeaders sets Headers value.
func (m *Message) WithHeaders(val map[string]interface{}) *Message {
	m.Headers = val
	return m
}

// WithHeadersItem sets Headers item value.
func (m *Message) WithHeadersItem(key string, val interface{}) *Message {
	if m.Headers == nil {
		m.Headers = make(map[string]interface{}, 1)
	}

	m.Headers[key] = val

	return m
}

// WithPayload sets Payload value.
func (m *Message) WithPayload(val map[string]interface{}) *Message {
	m.Payload = val
	return m
}

// WithPayloadItem sets Payload item value.
func (m *Message) WithPayloadItem(key string, val interface{}) *Message {
	if m.Payload == nil {
		m.Payload = make(map[string]interface{}, 1)
	}

	m.Payload[key] = val

	return m
}

// WithTags sets Tags value.
func (m *Message) WithTags(val ...Tag) *Message {
	m.Tags = val
	return m
}

// WithSummary sets Summary value.
func (m *Message) WithSummary(val string) *Message {
	m.Summary = val
	return m
}

// WithDescription sets Description value.
func (m *Message) WithDescription(val string) *Message {
	m.Description = val
	return m
}

// WithExternalDocs sets ExternalDocs value.
func (m *Message) WithExternalDocs(val ExternalDocs) *Message {
	m.ExternalDocs = &val
	return m
}

// ExternalDocsEns ensures returned ExternalDocs is not nil.
func (m *Message) ExternalDocsEns() *ExternalDocs {
	if m.ExternalDocs == nil {
		m.ExternalDocs = new(ExternalDocs)
	}

	return m.ExternalDocs
}

// WithDeprecated sets Deprecated value.
func (m *Message) WithDeprecated(val bool) *Message {
	m.Deprecated = val
	return m
}

// WithExample sets Example value.
func (m *Message) WithExample(val interface{}) *Message {
	m.Example = &val
	return m
}

// WithMapOfAnything sets MapOfAnything value.
func (m *Message) WithMapOfAnything(val map[string]interface{}) *Message {
	m.MapOfAnything = val
	return m
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (m *Message) WithMapOfAnythingItem(key string, val interface{}) *Message {
	if m.MapOfAnything == nil {
		m.MapOfAnything = make(map[string]interface{}, 1)
	}

	m.MapOfAnything[key] = val

	return m
}

type marshalMessage Message

var knownKeysMessage = []string{
	"$ref",
	"headers",
	"payload",
	"tags",
	"summary",
	"description",
	"externalDocs",
	"deprecated",
	"example",
}

// UnmarshalJSON decodes JSON.
func (m *Message) UnmarshalJSON(data []byte) error {
	var err error

	mm := marshalMessage(*m)

	err = json.Unmarshal(data, &mm)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if mm.Example == nil {
		if _, ok := rawMap["example"]; ok {
			var v interface{}
			mm.Example = &v
		}
	}

	for _, key := range knownKeysMessage {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mm.MapOfAnything == nil {
				mm.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mm.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in Message: %v", offendingKeys)
	}

	*m = Message(mm)

	return nil
}

// MarshalJSON encodes JSON.
func (m Message) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalMessage(m), m.MapOfAnything)
}

// Tag structure is generated from "#/definitions/tag".
type Tag struct {
	Name          string                 `json:"name"` // Required.
	Description   string                 `json:"description,omitempty"`
	ExternalDocs  *ExternalDocs          `json:"externalDocs,omitempty"` // Information about external documentation.
	MapOfAnything map[string]interface{} `json:"-"`                      // Key must match pattern: `^x-`.
}

// WithName sets Name value.
func (t *Tag) WithName(val string) *Tag {
	t.Name = val
	return t
}

// WithDescription sets Description value.
func (t *Tag) WithDescription(val string) *Tag {
	t.Description = val
	return t
}

// WithExternalDocs sets ExternalDocs value.
func (t *Tag) WithExternalDocs(val ExternalDocs) *Tag {
	t.ExternalDocs = &val
	return t
}

// ExternalDocsEns ensures returned ExternalDocs is not nil.
func (t *Tag) ExternalDocsEns() *ExternalDocs {
	if t.ExternalDocs == nil {
		t.ExternalDocs = new(ExternalDocs)
	}

	return t.ExternalDocs
}

// WithMapOfAnything sets MapOfAnything value.
func (t *Tag) WithMapOfAnything(val map[string]interface{}) *Tag {
	t.MapOfAnything = val
	return t
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (t *Tag) WithMapOfAnythingItem(key string, val interface{}) *Tag {
	if t.MapOfAnything == nil {
		t.MapOfAnything = make(map[string]interface{}, 1)
	}

	t.MapOfAnything[key] = val

	return t
}

type marshalTag Tag

var knownKeysTag = []string{
	"name",
	"description",
	"externalDocs",
}

var requireKeysTag = []string{
	"name",
}

// UnmarshalJSON decodes JSON.
func (t *Tag) UnmarshalJSON(data []byte) error {
	var err error

	mt := marshalTag(*t)

	err = json.Unmarshal(data, &mt)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range requireKeysTag {
		if _, found := rawMap[key]; !found {
			return errors.New("required key missing: " + key)
		}
	}

	for _, key := range knownKeysTag {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mt.MapOfAnything == nil {
				mt.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mt.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in Tag: %v", offendingKeys)
	}

	*t = Tag(mt)

	return nil
}

// MarshalJSON encodes JSON.
func (t Tag) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalTag(t), t.MapOfAnything)
}

// ExternalDocs structure is generated from "#/definitions/externalDocs".
//
// information about external documentation.
type ExternalDocs struct {
	Description string `json:"description,omitempty"`
	// Format: uri.
	// Required.
	URL           string                 `json:"url"`
	MapOfAnything map[string]interface{} `json:"-"` // Key must match pattern: `^x-`.
}

// WithDescription sets Description value.
func (e *ExternalDocs) WithDescription(val string) *ExternalDocs {
	e.Description = val
	return e
}

// WithURL sets URL value.
func (e *ExternalDocs) WithURL(val string) *ExternalDocs {
	e.URL = val
	return e
}

// WithMapOfAnything sets MapOfAnything value.
func (e *ExternalDocs) WithMapOfAnything(val map[string]interface{}) *ExternalDocs {
	e.MapOfAnything = val
	return e
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (e *ExternalDocs) WithMapOfAnythingItem(key string, val interface{}) *ExternalDocs {
	if e.MapOfAnything == nil {
		e.MapOfAnything = make(map[string]interface{}, 1)
	}

	e.MapOfAnything[key] = val

	return e
}

type marshalExternalDocs ExternalDocs

var knownKeysExternalDocs = []string{
	"description",
	"url",
}

var requireKeysExternalDocs = []string{
	"url",
}

// UnmarshalJSON decodes JSON.
func (e *ExternalDocs) UnmarshalJSON(data []byte) error {
	var err error

	me := marshalExternalDocs(*e)

	err = json.Unmarshal(data, &me)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range requireKeysExternalDocs {
		if _, found := rawMap[key]; !found {
			return errors.New("required key missing: " + key)
		}
	}

	for _, key := range knownKeysExternalDocs {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if me.MapOfAnything == nil {
				me.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			me.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in ExternalDocs: %v", offendingKeys)
	}

	*e = ExternalDocs(me)

	return nil
}

// MarshalJSON encodes JSON.
func (e ExternalDocs) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalExternalDocs(e), e.MapOfAnything)
}

// OperationOneOf1 structure is generated from "#/definitions/operation/oneOf/1".
type OperationOneOf1 struct {
	OneOf         []Message              `json:"oneOf"` // Required.
	MapOfAnything map[string]interface{} `json:"-"`     // Key must match pattern: `^x-`.
}

// WithOneOf sets OneOf value.
func (o *OperationOneOf1) WithOneOf(val ...Message) *OperationOneOf1 {
	o.OneOf = val
	return o
}

// WithMapOfAnything sets MapOfAnything value.
func (o *OperationOneOf1) WithMapOfAnything(val map[string]interface{}) *OperationOneOf1 {
	o.MapOfAnything = val
	return o
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (o *OperationOneOf1) WithMapOfAnythingItem(key string, val interface{}) *OperationOneOf1 {
	if o.MapOfAnything == nil {
		o.MapOfAnything = make(map[string]interface{}, 1)
	}

	o.MapOfAnything[key] = val

	return o
}

type marshalOperationOneOf1 OperationOneOf1

var knownKeysOperationOneOf1 = []string{
	"oneOf",
}

var requireKeysOperationOneOf1 = []string{
	"oneOf",
}

// UnmarshalJSON decodes JSON.
func (o *OperationOneOf1) UnmarshalJSON(data []byte) error {
	var err error

	mo := marshalOperationOneOf1(*o)

	err = json.Unmarshal(data, &mo)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range requireKeysOperationOneOf1 {
		if _, found := rawMap[key]; !found {
			return errors.New("required key missing: " + key)
		}
	}

	for _, key := range knownKeysOperationOneOf1 {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mo.MapOfAnything == nil {
				mo.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mo.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in OperationOneOf1: %v", offendingKeys)
	}

	*o = OperationOneOf1(mo)

	return nil
}

// MarshalJSON encodes JSON.
func (o OperationOneOf1) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalOperationOneOf1(o), o.MapOfAnything)
}

// Operation structure is generated from "#/definitions/operation".
type Operation struct {
	Message *Message         `json:"-"`
	OneOf1  *OperationOneOf1 `json:"-"`
}

// WithMessage sets Message value.
func (o *Operation) WithMessage(val Message) *Operation {
	o.Message = &val
	return o
}

// MessageEns ensures returned Message is not nil.
func (o *Operation) MessageEns() *Message {
	if o.Message == nil {
		o.Message = new(Message)
	}

	return o.Message
}

// WithOneOf1 sets OneOf1 value.
func (o *Operation) WithOneOf1(val OperationOneOf1) *Operation {
	o.OneOf1 = &val
	return o
}

// OneOf1Ens ensures returned OneOf1 is not nil.
func (o *Operation) OneOf1Ens() *OperationOneOf1 {
	if o.OneOf1 == nil {
		o.OneOf1 = new(OperationOneOf1)
	}

	return o.OneOf1
}

// UnmarshalJSON decodes JSON.
func (o *Operation) UnmarshalJSON(data []byte) error {
	var err error

	oneOfErrors := make(map[string]error, 2)
	oneOfValid := 0

	err = json.Unmarshal(data, &o.Message)
	if err != nil {
		oneOfErrors["Message"] = err
		o.Message = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &o.OneOf1)
	if err != nil {
		oneOfErrors["OneOf1"] = err
		o.OneOf1 = nil
	} else {
		oneOfValid++
	}

	if oneOfValid != 1 {
		return fmt.Errorf("oneOf constraint failed for Operation with %d valid results: %v", oneOfValid, oneOfErrors)
	}

	return nil
}

// MarshalJSON encodes JSON.
func (o Operation) MarshalJSON() ([]byte, error) {
	return marshalUnion(o.Message, o.OneOf1)
}

// StreamObject structure is generated from "#/definitions/stream".
//
// Stream Object.
type StreamObject struct {
	Framing       *StreamFramingObject   `json:"framing,omitempty"` // Stream Framing Object.
	Read          []Message              `json:"read,omitempty"`    // Stream Read Object.
	Write         []Message              `json:"write,omitempty"`   // Stream Write Object.
	MapOfAnything map[string]interface{} `json:"-"`                 // Key must match pattern: `^x-`.
}

// WithFraming sets Framing value.
func (s *StreamObject) WithFraming(val StreamFramingObject) *StreamObject {
	s.Framing = &val
	return s
}

// FramingEns ensures returned Framing is not nil.
func (s *StreamObject) FramingEns() *StreamFramingObject {
	if s.Framing == nil {
		s.Framing = new(StreamFramingObject)
	}

	return s.Framing
}

// WithRead sets Read value.
func (s *StreamObject) WithRead(val ...Message) *StreamObject {
	s.Read = val
	return s
}

// WithWrite sets Write value.
func (s *StreamObject) WithWrite(val ...Message) *StreamObject {
	s.Write = val
	return s
}

// WithMapOfAnything sets MapOfAnything value.
func (s *StreamObject) WithMapOfAnything(val map[string]interface{}) *StreamObject {
	s.MapOfAnything = val
	return s
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (s *StreamObject) WithMapOfAnythingItem(key string, val interface{}) *StreamObject {
	if s.MapOfAnything == nil {
		s.MapOfAnything = make(map[string]interface{}, 1)
	}

	s.MapOfAnything[key] = val

	return s
}

type marshalStreamObject StreamObject

var knownKeysStreamObject = []string{
	"framing",
	"read",
	"write",
}

// UnmarshalJSON decodes JSON.
func (s *StreamObject) UnmarshalJSON(data []byte) error {
	var err error

	ms := marshalStreamObject(*s)

	err = json.Unmarshal(data, &ms)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysStreamObject {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if ms.MapOfAnything == nil {
				ms.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ms.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in StreamObject: %v", offendingKeys)
	}

	*s = StreamObject(ms)

	return nil
}

// MarshalJSON encodes JSON.
func (s StreamObject) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalStreamObject(s), s.MapOfAnything)
}

// StreamFramingOneOf0 structure is generated from "#/definitions/stream->framing/oneOf/0".
type StreamFramingOneOf0 struct {
	Delimiter StreamFramingOneOf0Delimiter `json:"delimiter,omitempty"`
}

// WithDelimiter sets Delimiter value.
func (s *StreamFramingOneOf0) WithDelimiter(val StreamFramingOneOf0Delimiter) *StreamFramingOneOf0 {
	s.Delimiter = val
	return s
}

type marshalStreamFramingOneOf0 StreamFramingOneOf0

var knownKeysStreamFramingOneOf0 = []string{
	"delimiter",
	"type",
}

// UnmarshalJSON decodes JSON.
func (s *StreamFramingOneOf0) UnmarshalJSON(data []byte) error {
	var err error

	ms := marshalStreamFramingOneOf0(*s)

	err = json.Unmarshal(data, &ms)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, ok := rawMap["type"]; !ok || string(v) != `"chunked"` {
		return fmt.Errorf(`bad or missing const value for "type" ("chunked" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	for _, key := range knownKeysStreamFramingOneOf0 {
		delete(rawMap, key)
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in StreamFramingOneOf0: %v", offendingKeys)
	}

	*s = StreamFramingOneOf0(ms)

	return nil
}

var (
	// constStreamFramingOneOf0 is unconditionally added to JSON.
	constStreamFramingOneOf0 = json.RawMessage(`{"type":"chunked"}`)
)

// MarshalJSON encodes JSON.
func (s StreamFramingOneOf0) MarshalJSON() ([]byte, error) {
	return marshalUnion(constStreamFramingOneOf0, marshalStreamFramingOneOf0(s))
}

// StreamFramingOneOf1 structure is generated from "#/definitions/stream->framing/oneOf/1".
type StreamFramingOneOf1 struct {
}

// UnmarshalJSON decodes JSON.
func (s *StreamFramingOneOf1) UnmarshalJSON(data []byte) error {
	var err error

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, ok := rawMap["type"]; !ok || string(v) != `"sse"` {
		return fmt.Errorf(`bad or missing const value for "type" ("sse" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	if v, ok := rawMap["delimiter"]; !ok || string(v) != `"\\n\\n"` {
		return fmt.Errorf(`bad or missing const value for "delimiter" ("\\n\\n" expected, %s received)`, v)
	}

	delete(rawMap, "delimiter")

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in StreamFramingOneOf1: %v", offendingKeys)
	}

	return nil
}

var (
	// constStreamFramingOneOf1 is unconditionally added to JSON.
	constStreamFramingOneOf1 = json.RawMessage(`{"type":"sse","delimiter":"\\n\\n"}`)
)

// MarshalJSON encodes JSON.
func (s StreamFramingOneOf1) MarshalJSON() ([]byte, error) {
	return marshalUnion(constStreamFramingOneOf1)
}

// StreamFramingObject structure is generated from "#/definitions/stream->framing".
//
// Stream Framing Object.
type StreamFramingObject struct {
	StreamFramingOneOf0 *StreamFramingOneOf0   `json:"-"`
	StreamFramingOneOf1 *StreamFramingOneOf1   `json:"-"`
	MapOfAnything       map[string]interface{} `json:"-"` // Key must match pattern: `^x-`.
}

// WithStreamFramingOneOf0 sets StreamFramingOneOf0 value.
func (s *StreamFramingObject) WithStreamFramingOneOf0(val StreamFramingOneOf0) *StreamFramingObject {
	s.StreamFramingOneOf0 = &val
	return s
}

// StreamFramingOneOf0Ens ensures returned StreamFramingOneOf0 is not nil.
func (s *StreamFramingObject) StreamFramingOneOf0Ens() *StreamFramingOneOf0 {
	if s.StreamFramingOneOf0 == nil {
		s.StreamFramingOneOf0 = new(StreamFramingOneOf0)
	}

	return s.StreamFramingOneOf0
}

// WithStreamFramingOneOf1 sets StreamFramingOneOf1 value.
func (s *StreamFramingObject) WithStreamFramingOneOf1(val StreamFramingOneOf1) *StreamFramingObject {
	s.StreamFramingOneOf1 = &val
	return s
}

// StreamFramingOneOf1Ens ensures returned StreamFramingOneOf1 is not nil.
func (s *StreamFramingObject) StreamFramingOneOf1Ens() *StreamFramingOneOf1 {
	if s.StreamFramingOneOf1 == nil {
		s.StreamFramingOneOf1 = new(StreamFramingOneOf1)
	}

	return s.StreamFramingOneOf1
}

// WithMapOfAnything sets MapOfAnything value.
func (s *StreamFramingObject) WithMapOfAnything(val map[string]interface{}) *StreamFramingObject {
	s.MapOfAnything = val
	return s
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (s *StreamFramingObject) WithMapOfAnythingItem(key string, val interface{}) *StreamFramingObject {
	if s.MapOfAnything == nil {
		s.MapOfAnything = make(map[string]interface{}, 1)
	}

	s.MapOfAnything[key] = val

	return s
}

// UnmarshalJSON decodes JSON.
func (s *StreamFramingObject) UnmarshalJSON(data []byte) error {
	var err error

	oneOfErrors := make(map[string]error, 2)
	oneOfValid := 0

	err = json.Unmarshal(data, &s.StreamFramingOneOf0)
	if err != nil {
		oneOfErrors["StreamFramingOneOf0"] = err
		s.StreamFramingOneOf0 = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &s.StreamFramingOneOf1)
	if err != nil {
		oneOfErrors["StreamFramingOneOf1"] = err
		s.StreamFramingOneOf1 = nil
	} else {
		oneOfValid++
	}

	if oneOfValid != 1 {
		return fmt.Errorf("oneOf constraint failed for StreamFramingObject with %d valid results: %v", oneOfValid, oneOfErrors)
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if s.MapOfAnything == nil {
				s.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			s.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	return nil
}

// MarshalJSON encodes JSON.
func (s StreamFramingObject) MarshalJSON() ([]byte, error) {
	return marshalUnion(s.MapOfAnything, s.StreamFramingOneOf0, s.StreamFramingOneOf1)
}

// EventsObject structure is generated from "#/definitions/events".
//
// Events Object.
type EventsObject struct {
	Receive       []Message              `json:"receive,omitempty"` // Events Receive Object.
	Send          []Message              `json:"send,omitempty"`    // Events Send Object.
	MapOfAnything map[string]interface{} `json:"-"`                 // Key must match pattern: `^x-`.
}

// WithReceive sets Receive value.
func (e *EventsObject) WithReceive(val ...Message) *EventsObject {
	e.Receive = val
	return e
}

// WithSend sets Send value.
func (e *EventsObject) WithSend(val ...Message) *EventsObject {
	e.Send = val
	return e
}

// WithMapOfAnything sets MapOfAnything value.
func (e *EventsObject) WithMapOfAnything(val map[string]interface{}) *EventsObject {
	e.MapOfAnything = val
	return e
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (e *EventsObject) WithMapOfAnythingItem(key string, val interface{}) *EventsObject {
	if e.MapOfAnything == nil {
		e.MapOfAnything = make(map[string]interface{}, 1)
	}

	e.MapOfAnything[key] = val

	return e
}

type marshalEventsObject EventsObject

var knownKeysEventsObject = []string{
	"receive",
	"send",
}

// UnmarshalJSON decodes JSON.
func (e *EventsObject) UnmarshalJSON(data []byte) error {
	var err error

	me := marshalEventsObject(*e)

	err = json.Unmarshal(data, &me)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysEventsObject {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if me.MapOfAnything == nil {
				me.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			me.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in EventsObject: %v", offendingKeys)
	}

	*e = EventsObject(me)

	return nil
}

// MarshalJSON encodes JSON.
func (e EventsObject) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalEventsObject(e), e.MapOfAnything)
}

// Components structure is generated from "#/definitions/components".
//
// An object to hold a set of reusable objects for different aspects of the AsyncAPI Specification.
type Components struct {
	Schemas         map[string]map[string]interface{} `json:"schemas,omitempty"`  // JSON objects describing schemas the API uses.
	Messages        map[string]Message                `json:"messages,omitempty"` // JSON objects describing the messages being consumed and produced by the API.
	SecuritySchemes *ComponentsSecuritySchemes        `json:"securitySchemes,omitempty"`
	Parameters      map[string]Parameter              `json:"parameters,omitempty"` // JSON objects describing re-usable topic parameters.
}

// WithSchemas sets Schemas value.
func (c *Components) WithSchemas(val map[string]map[string]interface{}) *Components {
	c.Schemas = val
	return c
}

// WithSchemasItem sets Schemas item value.
func (c *Components) WithSchemasItem(key string, val map[string]interface{}) *Components {
	if c.Schemas == nil {
		c.Schemas = make(map[string]map[string]interface{}, 1)
	}

	c.Schemas[key] = val

	return c
}

// WithMessages sets Messages value.
func (c *Components) WithMessages(val map[string]Message) *Components {
	c.Messages = val
	return c
}

// WithMessagesItem sets Messages item value.
func (c *Components) WithMessagesItem(key string, val Message) *Components {
	if c.Messages == nil {
		c.Messages = make(map[string]Message, 1)
	}

	c.Messages[key] = val

	return c
}

// WithSecuritySchemes sets SecuritySchemes value.
func (c *Components) WithSecuritySchemes(val ComponentsSecuritySchemes) *Components {
	c.SecuritySchemes = &val
	return c
}

// SecuritySchemesEns ensures returned SecuritySchemes is not nil.
func (c *Components) SecuritySchemesEns() *ComponentsSecuritySchemes {
	if c.SecuritySchemes == nil {
		c.SecuritySchemes = new(ComponentsSecuritySchemes)
	}

	return c.SecuritySchemes
}

// WithParameters sets Parameters value.
func (c *Components) WithParameters(val map[string]Parameter) *Components {
	c.Parameters = val
	return c
}

// WithParametersItem sets Parameters item value.
func (c *Components) WithParametersItem(key string, val Parameter) *Components {
	if c.Parameters == nil {
		c.Parameters = make(map[string]Parameter, 1)
	}

	c.Parameters[key] = val

	return c
}

type marshalComponents Components

var knownKeysComponents = []string{
	"schemas",
	"messages",
	"securitySchemes",
	"parameters",
}

// UnmarshalJSON decodes JSON.
func (c *Components) UnmarshalJSON(data []byte) error {
	var err error

	mc := marshalComponents(*c)

	err = json.Unmarshal(data, &mc)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysComponents {
		delete(rawMap, key)
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in Components: %v", offendingKeys)
	}

	*c = Components(mc)

	return nil
}

// Reference structure is generated from "#/definitions/Reference".
type Reference struct {
	// Format: uri.
	// Required.
	Ref string `json:"$ref"`
}

// WithRef sets Ref value.
func (r *Reference) WithRef(val string) *Reference {
	r.Ref = val
	return r
}

type marshalReference Reference

var requireKeysReference = []string{
	"$ref",
}

// UnmarshalJSON decodes JSON.
func (r *Reference) UnmarshalJSON(data []byte) error {
	var err error

	mr := marshalReference(*r)

	err = json.Unmarshal(data, &mr)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range requireKeysReference {
		if _, found := rawMap[key]; !found {
			return errors.New("required key missing: " + key)
		}
	}

	*r = Reference(mr)

	return nil
}

// UserPassword structure is generated from "#/definitions/userPassword".
type UserPassword struct {
	Description   string                 `json:"description,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"` // Key must match pattern: `^x-`.
}

// WithDescription sets Description value.
func (u *UserPassword) WithDescription(val string) *UserPassword {
	u.Description = val
	return u
}

// WithMapOfAnything sets MapOfAnything value.
func (u *UserPassword) WithMapOfAnything(val map[string]interface{}) *UserPassword {
	u.MapOfAnything = val
	return u
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (u *UserPassword) WithMapOfAnythingItem(key string, val interface{}) *UserPassword {
	if u.MapOfAnything == nil {
		u.MapOfAnything = make(map[string]interface{}, 1)
	}

	u.MapOfAnything[key] = val

	return u
}

type marshalUserPassword UserPassword

var knownKeysUserPassword = []string{
	"description",
	"type",
}

var requireKeysUserPassword = []string{
	"type",
}

// UnmarshalJSON decodes JSON.
func (u *UserPassword) UnmarshalJSON(data []byte) error {
	var err error

	mu := marshalUserPassword(*u)

	err = json.Unmarshal(data, &mu)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range requireKeysUserPassword {
		if _, found := rawMap[key]; !found {
			return errors.New("required key missing: " + key)
		}
	}

	if v, ok := rawMap["type"]; !ok || string(v) != `"userPassword"` {
		return fmt.Errorf(`bad or missing const value for "type" ("userPassword" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	for _, key := range knownKeysUserPassword {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mu.MapOfAnything == nil {
				mu.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mu.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in UserPassword: %v", offendingKeys)
	}

	*u = UserPassword(mu)

	return nil
}

var (
	// constUserPassword is unconditionally added to JSON.
	constUserPassword = json.RawMessage(`{"type":"userPassword"}`)
)

// MarshalJSON encodes JSON.
func (u UserPassword) MarshalJSON() ([]byte, error) {
	return marshalUnion(constUserPassword, marshalUserPassword(u), u.MapOfAnything)
}

// APIKey structure is generated from "#/definitions/apiKey".
type APIKey struct {
	In            APIKeyIn               `json:"in"` // Required.
	Description   string                 `json:"description,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"` // Key must match pattern: `^x-`.
}

// WithIn sets In value.
func (a *APIKey) WithIn(val APIKeyIn) *APIKey {
	a.In = val
	return a
}

// WithDescription sets Description value.
func (a *APIKey) WithDescription(val string) *APIKey {
	a.Description = val
	return a
}

// WithMapOfAnything sets MapOfAnything value.
func (a *APIKey) WithMapOfAnything(val map[string]interface{}) *APIKey {
	a.MapOfAnything = val
	return a
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (a *APIKey) WithMapOfAnythingItem(key string, val interface{}) *APIKey {
	if a.MapOfAnything == nil {
		a.MapOfAnything = make(map[string]interface{}, 1)
	}

	a.MapOfAnything[key] = val

	return a
}

type marshalAPIKey APIKey

var knownKeysAPIKey = []string{
	"in",
	"description",
	"type",
}

var requireKeysAPIKey = []string{
	"type",
	"in",
}

// UnmarshalJSON decodes JSON.
func (a *APIKey) UnmarshalJSON(data []byte) error {
	var err error

	ma := marshalAPIKey(*a)

	err = json.Unmarshal(data, &ma)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range requireKeysAPIKey {
		if _, found := rawMap[key]; !found {
			return errors.New("required key missing: " + key)
		}
	}

	if v, ok := rawMap["type"]; !ok || string(v) != `"apiKey"` {
		return fmt.Errorf(`bad or missing const value for "type" ("apiKey" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	for _, key := range knownKeysAPIKey {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if ma.MapOfAnything == nil {
				ma.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ma.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in APIKey: %v", offendingKeys)
	}

	*a = APIKey(ma)

	return nil
}

var (
	// constAPIKey is unconditionally added to JSON.
	constAPIKey = json.RawMessage(`{"type":"apiKey"}`)
)

// MarshalJSON encodes JSON.
func (a APIKey) MarshalJSON() ([]byte, error) {
	return marshalUnion(constAPIKey, marshalAPIKey(a), a.MapOfAnything)
}

// X509 structure is generated from "#/definitions/X509".
type X509 struct {
	Description   string                 `json:"description,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"` // Key must match pattern: `^x-`.
}

// WithDescription sets Description value.
func (x *X509) WithDescription(val string) *X509 {
	x.Description = val
	return x
}

// WithMapOfAnything sets MapOfAnything value.
func (x *X509) WithMapOfAnything(val map[string]interface{}) *X509 {
	x.MapOfAnything = val
	return x
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (x *X509) WithMapOfAnythingItem(key string, val interface{}) *X509 {
	if x.MapOfAnything == nil {
		x.MapOfAnything = make(map[string]interface{}, 1)
	}

	x.MapOfAnything[key] = val

	return x
}

type marshalX509 X509

var knownKeysX509 = []string{
	"description",
	"type",
}

var requireKeysX509 = []string{
	"type",
}

// UnmarshalJSON decodes JSON.
func (x *X509) UnmarshalJSON(data []byte) error {
	var err error

	mx := marshalX509(*x)

	err = json.Unmarshal(data, &mx)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range requireKeysX509 {
		if _, found := rawMap[key]; !found {
			return errors.New("required key missing: " + key)
		}
	}

	if v, ok := rawMap["type"]; !ok || string(v) != `"X509"` {
		return fmt.Errorf(`bad or missing const value for "type" ("X509" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	for _, key := range knownKeysX509 {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mx.MapOfAnything == nil {
				mx.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mx.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in X509: %v", offendingKeys)
	}

	*x = X509(mx)

	return nil
}

var (
	// constX509 is unconditionally added to JSON.
	constX509 = json.RawMessage(`{"type":"X509"}`)
)

// MarshalJSON encodes JSON.
func (x X509) MarshalJSON() ([]byte, error) {
	return marshalUnion(constX509, marshalX509(x), x.MapOfAnything)
}

// SymmetricEncryption structure is generated from "#/definitions/symmetricEncryption".
type SymmetricEncryption struct {
	Description   string                 `json:"description,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"` // Key must match pattern: `^x-`.
}

// WithDescription sets Description value.
func (s *SymmetricEncryption) WithDescription(val string) *SymmetricEncryption {
	s.Description = val
	return s
}

// WithMapOfAnything sets MapOfAnything value.
func (s *SymmetricEncryption) WithMapOfAnything(val map[string]interface{}) *SymmetricEncryption {
	s.MapOfAnything = val
	return s
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (s *SymmetricEncryption) WithMapOfAnythingItem(key string, val interface{}) *SymmetricEncryption {
	if s.MapOfAnything == nil {
		s.MapOfAnything = make(map[string]interface{}, 1)
	}

	s.MapOfAnything[key] = val

	return s
}

type marshalSymmetricEncryption SymmetricEncryption

var knownKeysSymmetricEncryption = []string{
	"description",
	"type",
}

var requireKeysSymmetricEncryption = []string{
	"type",
}

// UnmarshalJSON decodes JSON.
func (s *SymmetricEncryption) UnmarshalJSON(data []byte) error {
	var err error

	ms := marshalSymmetricEncryption(*s)

	err = json.Unmarshal(data, &ms)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range requireKeysSymmetricEncryption {
		if _, found := rawMap[key]; !found {
			return errors.New("required key missing: " + key)
		}
	}

	if v, ok := rawMap["type"]; !ok || string(v) != `"symmetricEncryption"` {
		return fmt.Errorf(`bad or missing const value for "type" ("symmetricEncryption" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	for _, key := range knownKeysSymmetricEncryption {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if ms.MapOfAnything == nil {
				ms.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ms.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in SymmetricEncryption: %v", offendingKeys)
	}

	*s = SymmetricEncryption(ms)

	return nil
}

var (
	// constSymmetricEncryption is unconditionally added to JSON.
	constSymmetricEncryption = json.RawMessage(`{"type":"symmetricEncryption"}`)
)

// MarshalJSON encodes JSON.
func (s SymmetricEncryption) MarshalJSON() ([]byte, error) {
	return marshalUnion(constSymmetricEncryption, marshalSymmetricEncryption(s), s.MapOfAnything)
}

// AsymmetricEncryption structure is generated from "#/definitions/asymmetricEncryption".
type AsymmetricEncryption struct {
	Description   string                 `json:"description,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"` // Key must match pattern: `^x-`.
}

// WithDescription sets Description value.
func (a *AsymmetricEncryption) WithDescription(val string) *AsymmetricEncryption {
	a.Description = val
	return a
}

// WithMapOfAnything sets MapOfAnything value.
func (a *AsymmetricEncryption) WithMapOfAnything(val map[string]interface{}) *AsymmetricEncryption {
	a.MapOfAnything = val
	return a
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (a *AsymmetricEncryption) WithMapOfAnythingItem(key string, val interface{}) *AsymmetricEncryption {
	if a.MapOfAnything == nil {
		a.MapOfAnything = make(map[string]interface{}, 1)
	}

	a.MapOfAnything[key] = val

	return a
}

type marshalAsymmetricEncryption AsymmetricEncryption

var knownKeysAsymmetricEncryption = []string{
	"description",
	"type",
}

var requireKeysAsymmetricEncryption = []string{
	"type",
}

// UnmarshalJSON decodes JSON.
func (a *AsymmetricEncryption) UnmarshalJSON(data []byte) error {
	var err error

	ma := marshalAsymmetricEncryption(*a)

	err = json.Unmarshal(data, &ma)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range requireKeysAsymmetricEncryption {
		if _, found := rawMap[key]; !found {
			return errors.New("required key missing: " + key)
		}
	}

	if v, ok := rawMap["type"]; !ok || string(v) != `"asymmetricEncryption"` {
		return fmt.Errorf(`bad or missing const value for "type" ("asymmetricEncryption" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	for _, key := range knownKeysAsymmetricEncryption {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if ma.MapOfAnything == nil {
				ma.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ma.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in AsymmetricEncryption: %v", offendingKeys)
	}

	*a = AsymmetricEncryption(ma)

	return nil
}

var (
	// constAsymmetricEncryption is unconditionally added to JSON.
	constAsymmetricEncryption = json.RawMessage(`{"type":"asymmetricEncryption"}`)
)

// MarshalJSON encodes JSON.
func (a AsymmetricEncryption) MarshalJSON() ([]byte, error) {
	return marshalUnion(constAsymmetricEncryption, marshalAsymmetricEncryption(a), a.MapOfAnything)
}

// NonBearerHTTPSecurityScheme structure is generated from "#/definitions/NonBearerHTTPSecurityScheme".
type NonBearerHTTPSecurityScheme struct {
	Scheme        string                 `json:"scheme"` // Required.
	Description   string                 `json:"description,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"` // Key must match pattern: `^x-`.
}

// WithScheme sets Scheme value.
func (n *NonBearerHTTPSecurityScheme) WithScheme(val string) *NonBearerHTTPSecurityScheme {
	n.Scheme = val
	return n
}

// WithDescription sets Description value.
func (n *NonBearerHTTPSecurityScheme) WithDescription(val string) *NonBearerHTTPSecurityScheme {
	n.Description = val
	return n
}

// WithMapOfAnything sets MapOfAnything value.
func (n *NonBearerHTTPSecurityScheme) WithMapOfAnything(val map[string]interface{}) *NonBearerHTTPSecurityScheme {
	n.MapOfAnything = val
	return n
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (n *NonBearerHTTPSecurityScheme) WithMapOfAnythingItem(key string, val interface{}) *NonBearerHTTPSecurityScheme {
	if n.MapOfAnything == nil {
		n.MapOfAnything = make(map[string]interface{}, 1)
	}

	n.MapOfAnything[key] = val

	return n
}

type marshalNonBearerHTTPSecurityScheme NonBearerHTTPSecurityScheme

var knownKeysNonBearerHTTPSecurityScheme = []string{
	"scheme",
	"description",
	"type",
}

var requireKeysNonBearerHTTPSecurityScheme = []string{
	"scheme",
	"type",
}

// UnmarshalJSON decodes JSON.
func (n *NonBearerHTTPSecurityScheme) UnmarshalJSON(data []byte) error {
	var err error

	var not NonBearerHTTPSecuritySchemeNot

	if json.Unmarshal(data, &not) == nil {
		return errors.New("not constraint failed for NonBearerHTTPSecurityScheme")
	}

	mn := marshalNonBearerHTTPSecurityScheme(*n)

	err = json.Unmarshal(data, &mn)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range requireKeysNonBearerHTTPSecurityScheme {
		if _, found := rawMap[key]; !found {
			return errors.New("required key missing: " + key)
		}
	}

	if v, ok := rawMap["type"]; !ok || string(v) != `"http"` {
		return fmt.Errorf(`bad or missing const value for "type" ("http" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	for _, key := range knownKeysNonBearerHTTPSecurityScheme {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mn.MapOfAnything == nil {
				mn.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mn.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in NonBearerHTTPSecurityScheme: %v", offendingKeys)
	}

	*n = NonBearerHTTPSecurityScheme(mn)

	return nil
}

var (
	// constNonBearerHTTPSecurityScheme is unconditionally added to JSON.
	constNonBearerHTTPSecurityScheme = json.RawMessage(`{"type":"http"}`)
)

// MarshalJSON encodes JSON.
func (n NonBearerHTTPSecurityScheme) MarshalJSON() ([]byte, error) {
	return marshalUnion(constNonBearerHTTPSecurityScheme, marshalNonBearerHTTPSecurityScheme(n), n.MapOfAnything)
}

// NonBearerHTTPSecuritySchemeNot structure is generated from "#/definitions/NonBearerHTTPSecurityScheme->not".
type NonBearerHTTPSecuritySchemeNot struct {
}

// UnmarshalJSON decodes JSON.
func (n *NonBearerHTTPSecuritySchemeNot) UnmarshalJSON(data []byte) error {
	var err error

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, ok := rawMap["scheme"]; !ok || string(v) != `"bearer"` {
		return fmt.Errorf(`bad or missing const value for "scheme" ("bearer" expected, %s received)`, v)
	}

	delete(rawMap, "scheme")

	return nil
}

var (
	// constNonBearerHTTPSecuritySchemeNot is unconditionally added to JSON.
	constNonBearerHTTPSecuritySchemeNot = json.RawMessage(`{"scheme":"bearer"}`)
)

// MarshalJSON encodes JSON.
func (n NonBearerHTTPSecuritySchemeNot) MarshalJSON() ([]byte, error) {
	return marshalUnion(constNonBearerHTTPSecuritySchemeNot)
}

// BearerHTTPSecurityScheme structure is generated from "#/definitions/BearerHTTPSecurityScheme".
type BearerHTTPSecurityScheme struct {
	BearerFormat  string                 `json:"bearerFormat,omitempty"`
	Description   string                 `json:"description,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"` // Key must match pattern: `^x-`.
}

// WithBearerFormat sets BearerFormat value.
func (b *BearerHTTPSecurityScheme) WithBearerFormat(val string) *BearerHTTPSecurityScheme {
	b.BearerFormat = val
	return b
}

// WithDescription sets Description value.
func (b *BearerHTTPSecurityScheme) WithDescription(val string) *BearerHTTPSecurityScheme {
	b.Description = val
	return b
}

// WithMapOfAnything sets MapOfAnything value.
func (b *BearerHTTPSecurityScheme) WithMapOfAnything(val map[string]interface{}) *BearerHTTPSecurityScheme {
	b.MapOfAnything = val
	return b
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (b *BearerHTTPSecurityScheme) WithMapOfAnythingItem(key string, val interface{}) *BearerHTTPSecurityScheme {
	if b.MapOfAnything == nil {
		b.MapOfAnything = make(map[string]interface{}, 1)
	}

	b.MapOfAnything[key] = val

	return b
}

type marshalBearerHTTPSecurityScheme BearerHTTPSecurityScheme

var knownKeysBearerHTTPSecurityScheme = []string{
	"bearerFormat",
	"description",
	"scheme",
	"type",
}

var requireKeysBearerHTTPSecurityScheme = []string{
	"type",
	"scheme",
}

// UnmarshalJSON decodes JSON.
func (b *BearerHTTPSecurityScheme) UnmarshalJSON(data []byte) error {
	var err error

	mb := marshalBearerHTTPSecurityScheme(*b)

	err = json.Unmarshal(data, &mb)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range requireKeysBearerHTTPSecurityScheme {
		if _, found := rawMap[key]; !found {
			return errors.New("required key missing: " + key)
		}
	}

	if v, ok := rawMap["scheme"]; !ok || string(v) != `"bearer"` {
		return fmt.Errorf(`bad or missing const value for "scheme" ("bearer" expected, %s received)`, v)
	}

	delete(rawMap, "scheme")

	if v, ok := rawMap["type"]; !ok || string(v) != `"http"` {
		return fmt.Errorf(`bad or missing const value for "type" ("http" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	for _, key := range knownKeysBearerHTTPSecurityScheme {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if mb.MapOfAnything == nil {
				mb.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mb.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in BearerHTTPSecurityScheme: %v", offendingKeys)
	}

	*b = BearerHTTPSecurityScheme(mb)

	return nil
}

var (
	// constBearerHTTPSecurityScheme is unconditionally added to JSON.
	constBearerHTTPSecurityScheme = json.RawMessage(`{"scheme":"bearer","type":"http"}`)
)

// MarshalJSON encodes JSON.
func (b BearerHTTPSecurityScheme) MarshalJSON() ([]byte, error) {
	return marshalUnion(constBearerHTTPSecurityScheme, marshalBearerHTTPSecurityScheme(b), b.MapOfAnything)
}

// APIKeyHTTPSecurityScheme structure is generated from "#/definitions/APIKeyHTTPSecurityScheme".
type APIKeyHTTPSecurityScheme struct {
	Name          string                     `json:"name"` // Required.
	In            APIKeyHTTPSecuritySchemeIn `json:"in"`   // Required.
	Description   string                     `json:"description,omitempty"`
	MapOfAnything map[string]interface{}     `json:"-"` // Key must match pattern: `^x-`.
}

// WithName sets Name value.
func (a *APIKeyHTTPSecurityScheme) WithName(val string) *APIKeyHTTPSecurityScheme {
	a.Name = val
	return a
}

// WithIn sets In value.
func (a *APIKeyHTTPSecurityScheme) WithIn(val APIKeyHTTPSecuritySchemeIn) *APIKeyHTTPSecurityScheme {
	a.In = val
	return a
}

// WithDescription sets Description value.
func (a *APIKeyHTTPSecurityScheme) WithDescription(val string) *APIKeyHTTPSecurityScheme {
	a.Description = val
	return a
}

// WithMapOfAnything sets MapOfAnything value.
func (a *APIKeyHTTPSecurityScheme) WithMapOfAnything(val map[string]interface{}) *APIKeyHTTPSecurityScheme {
	a.MapOfAnything = val
	return a
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (a *APIKeyHTTPSecurityScheme) WithMapOfAnythingItem(key string, val interface{}) *APIKeyHTTPSecurityScheme {
	if a.MapOfAnything == nil {
		a.MapOfAnything = make(map[string]interface{}, 1)
	}

	a.MapOfAnything[key] = val

	return a
}

type marshalAPIKeyHTTPSecurityScheme APIKeyHTTPSecurityScheme

var knownKeysAPIKeyHTTPSecurityScheme = []string{
	"name",
	"in",
	"description",
	"type",
}

var requireKeysAPIKeyHTTPSecurityScheme = []string{
	"type",
	"name",
	"in",
}

// UnmarshalJSON decodes JSON.
func (a *APIKeyHTTPSecurityScheme) UnmarshalJSON(data []byte) error {
	var err error

	ma := marshalAPIKeyHTTPSecurityScheme(*a)

	err = json.Unmarshal(data, &ma)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range requireKeysAPIKeyHTTPSecurityScheme {
		if _, found := rawMap[key]; !found {
			return errors.New("required key missing: " + key)
		}
	}

	if v, ok := rawMap["type"]; !ok || string(v) != `"httpApiKey"` {
		return fmt.Errorf(`bad or missing const value for "type" ("httpApiKey" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	for _, key := range knownKeysAPIKeyHTTPSecurityScheme {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexX.MatchString(key) {
			matched = true

			if ma.MapOfAnything == nil {
				ma.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ma.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in APIKeyHTTPSecurityScheme: %v", offendingKeys)
	}

	*a = APIKeyHTTPSecurityScheme(ma)

	return nil
}

var (
	// constAPIKeyHTTPSecurityScheme is unconditionally added to JSON.
	constAPIKeyHTTPSecurityScheme = json.RawMessage(`{"type":"httpApiKey"}`)
)

// MarshalJSON encodes JSON.
func (a APIKeyHTTPSecurityScheme) MarshalJSON() ([]byte, error) {
	return marshalUnion(constAPIKeyHTTPSecurityScheme, marshalAPIKeyHTTPSecurityScheme(a), a.MapOfAnything)
}

// HTTPSecurityScheme structure is generated from "#/definitions/HTTPSecurityScheme".
type HTTPSecurityScheme struct {
	NonBearerHTTPSecurityScheme *NonBearerHTTPSecurityScheme `json:"-"`
	BearerHTTPSecurityScheme    *BearerHTTPSecurityScheme    `json:"-"`
	APIKeyHTTPSecurityScheme    *APIKeyHTTPSecurityScheme    `json:"-"`
}

// WithNonBearerHTTPSecurityScheme sets NonBearerHTTPSecurityScheme value.
func (h *HTTPSecurityScheme) WithNonBearerHTTPSecurityScheme(val NonBearerHTTPSecurityScheme) *HTTPSecurityScheme {
	h.NonBearerHTTPSecurityScheme = &val
	return h
}

// NonBearerHTTPSecuritySchemeEns ensures returned NonBearerHTTPSecurityScheme is not nil.
func (h *HTTPSecurityScheme) NonBearerHTTPSecuritySchemeEns() *NonBearerHTTPSecurityScheme {
	if h.NonBearerHTTPSecurityScheme == nil {
		h.NonBearerHTTPSecurityScheme = new(NonBearerHTTPSecurityScheme)
	}

	return h.NonBearerHTTPSecurityScheme
}

// WithBearerHTTPSecurityScheme sets BearerHTTPSecurityScheme value.
func (h *HTTPSecurityScheme) WithBearerHTTPSecurityScheme(val BearerHTTPSecurityScheme) *HTTPSecurityScheme {
	h.BearerHTTPSecurityScheme = &val
	return h
}

// BearerHTTPSecuritySchemeEns ensures returned BearerHTTPSecurityScheme is not nil.
func (h *HTTPSecurityScheme) BearerHTTPSecuritySchemeEns() *BearerHTTPSecurityScheme {
	if h.BearerHTTPSecurityScheme == nil {
		h.BearerHTTPSecurityScheme = new(BearerHTTPSecurityScheme)
	}

	return h.BearerHTTPSecurityScheme
}

// WithAPIKeyHTTPSecurityScheme sets APIKeyHTTPSecurityScheme value.
func (h *HTTPSecurityScheme) WithAPIKeyHTTPSecurityScheme(val APIKeyHTTPSecurityScheme) *HTTPSecurityScheme {
	h.APIKeyHTTPSecurityScheme = &val
	return h
}

// APIKeyHTTPSecuritySchemeEns ensures returned APIKeyHTTPSecurityScheme is not nil.
func (h *HTTPSecurityScheme) APIKeyHTTPSecuritySchemeEns() *APIKeyHTTPSecurityScheme {
	if h.APIKeyHTTPSecurityScheme == nil {
		h.APIKeyHTTPSecurityScheme = new(APIKeyHTTPSecurityScheme)
	}

	return h.APIKeyHTTPSecurityScheme
}

// UnmarshalJSON decodes JSON.
func (h *HTTPSecurityScheme) UnmarshalJSON(data []byte) error {
	var err error

	oneOfErrors := make(map[string]error, 3)
	oneOfValid := 0

	err = json.Unmarshal(data, &h.NonBearerHTTPSecurityScheme)
	if err != nil {
		oneOfErrors["NonBearerHTTPSecurityScheme"] = err
		h.NonBearerHTTPSecurityScheme = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &h.BearerHTTPSecurityScheme)
	if err != nil {
		oneOfErrors["BearerHTTPSecurityScheme"] = err
		h.BearerHTTPSecurityScheme = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &h.APIKeyHTTPSecurityScheme)
	if err != nil {
		oneOfErrors["APIKeyHTTPSecurityScheme"] = err
		h.APIKeyHTTPSecurityScheme = nil
	} else {
		oneOfValid++
	}

	if oneOfValid != 1 {
		return fmt.Errorf("oneOf constraint failed for HTTPSecurityScheme with %d valid results: %v", oneOfValid, oneOfErrors)
	}

	return nil
}

// MarshalJSON encodes JSON.
func (h HTTPSecurityScheme) MarshalJSON() ([]byte, error) {
	return marshalUnion(h.NonBearerHTTPSecurityScheme, h.BearerHTTPSecurityScheme, h.APIKeyHTTPSecurityScheme)
}

// SecurityScheme structure is generated from "#/definitions/SecurityScheme".
type SecurityScheme struct {
	UserPassword         *UserPassword         `json:"-"`
	APIKey               *APIKey               `json:"-"`
	X509                 *X509                 `json:"-"`
	SymmetricEncryption  *SymmetricEncryption  `json:"-"`
	AsymmetricEncryption *AsymmetricEncryption `json:"-"`
	HTTPSecurityScheme   *HTTPSecurityScheme   `json:"-"`
}

// WithUserPassword sets UserPassword value.
func (s *SecurityScheme) WithUserPassword(val UserPassword) *SecurityScheme {
	s.UserPassword = &val
	return s
}

// UserPasswordEns ensures returned UserPassword is not nil.
func (s *SecurityScheme) UserPasswordEns() *UserPassword {
	if s.UserPassword == nil {
		s.UserPassword = new(UserPassword)
	}

	return s.UserPassword
}

// WithAPIKey sets APIKey value.
func (s *SecurityScheme) WithAPIKey(val APIKey) *SecurityScheme {
	s.APIKey = &val
	return s
}

// APIKeyEns ensures returned APIKey is not nil.
func (s *SecurityScheme) APIKeyEns() *APIKey {
	if s.APIKey == nil {
		s.APIKey = new(APIKey)
	}

	return s.APIKey
}

// WithX509 sets X509 value.
func (s *SecurityScheme) WithX509(val X509) *SecurityScheme {
	s.X509 = &val
	return s
}

// X509Ens ensures returned X509 is not nil.
func (s *SecurityScheme) X509Ens() *X509 {
	if s.X509 == nil {
		s.X509 = new(X509)
	}

	return s.X509
}

// WithSymmetricEncryption sets SymmetricEncryption value.
func (s *SecurityScheme) WithSymmetricEncryption(val SymmetricEncryption) *SecurityScheme {
	s.SymmetricEncryption = &val
	return s
}

// SymmetricEncryptionEns ensures returned SymmetricEncryption is not nil.
func (s *SecurityScheme) SymmetricEncryptionEns() *SymmetricEncryption {
	if s.SymmetricEncryption == nil {
		s.SymmetricEncryption = new(SymmetricEncryption)
	}

	return s.SymmetricEncryption
}

// WithAsymmetricEncryption sets AsymmetricEncryption value.
func (s *SecurityScheme) WithAsymmetricEncryption(val AsymmetricEncryption) *SecurityScheme {
	s.AsymmetricEncryption = &val
	return s
}

// AsymmetricEncryptionEns ensures returned AsymmetricEncryption is not nil.
func (s *SecurityScheme) AsymmetricEncryptionEns() *AsymmetricEncryption {
	if s.AsymmetricEncryption == nil {
		s.AsymmetricEncryption = new(AsymmetricEncryption)
	}

	return s.AsymmetricEncryption
}

// WithHTTPSecurityScheme sets HTTPSecurityScheme value.
func (s *SecurityScheme) WithHTTPSecurityScheme(val HTTPSecurityScheme) *SecurityScheme {
	s.HTTPSecurityScheme = &val
	return s
}

// HTTPSecuritySchemeEns ensures returned HTTPSecurityScheme is not nil.
func (s *SecurityScheme) HTTPSecuritySchemeEns() *HTTPSecurityScheme {
	if s.HTTPSecurityScheme == nil {
		s.HTTPSecurityScheme = new(HTTPSecurityScheme)
	}

	return s.HTTPSecurityScheme
}

// UnmarshalJSON decodes JSON.
func (s *SecurityScheme) UnmarshalJSON(data []byte) error {
	var err error

	oneOfErrors := make(map[string]error, 6)
	oneOfValid := 0

	err = json.Unmarshal(data, &s.UserPassword)
	if err != nil {
		oneOfErrors["UserPassword"] = err
		s.UserPassword = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &s.APIKey)
	if err != nil {
		oneOfErrors["APIKey"] = err
		s.APIKey = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &s.X509)
	if err != nil {
		oneOfErrors["X509"] = err
		s.X509 = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &s.SymmetricEncryption)
	if err != nil {
		oneOfErrors["SymmetricEncryption"] = err
		s.SymmetricEncryption = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &s.AsymmetricEncryption)
	if err != nil {
		oneOfErrors["AsymmetricEncryption"] = err
		s.AsymmetricEncryption = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &s.HTTPSecurityScheme)
	if err != nil {
		oneOfErrors["HTTPSecurityScheme"] = err
		s.HTTPSecurityScheme = nil
	} else {
		oneOfValid++
	}

	if oneOfValid != 1 {
		return fmt.Errorf("oneOf constraint failed for SecurityScheme with %d valid results: %v", oneOfValid, oneOfErrors)
	}

	return nil
}

// MarshalJSON encodes JSON.
func (s SecurityScheme) MarshalJSON() ([]byte, error) {
	return marshalUnion(s.UserPassword, s.APIKey, s.X509, s.SymmetricEncryption, s.AsymmetricEncryption, s.HTTPSecurityScheme)
}

// ComponentsSecuritySchemesAZAZ09 structure is generated from "#/definitions/components->securitySchemes->^[a-zA-Z0-9\.\-_]+$".
type ComponentsSecuritySchemesAZAZ09 struct {
	Reference      *Reference      `json:"-"`
	SecurityScheme *SecurityScheme `json:"-"`
}

// WithReference sets Reference value.
func (c *ComponentsSecuritySchemesAZAZ09) WithReference(val Reference) *ComponentsSecuritySchemesAZAZ09 {
	c.Reference = &val
	return c
}

// ReferenceEns ensures returned Reference is not nil.
func (c *ComponentsSecuritySchemesAZAZ09) ReferenceEns() *Reference {
	if c.Reference == nil {
		c.Reference = new(Reference)
	}

	return c.Reference
}

// WithSecurityScheme sets SecurityScheme value.
func (c *ComponentsSecuritySchemesAZAZ09) WithSecurityScheme(val SecurityScheme) *ComponentsSecuritySchemesAZAZ09 {
	c.SecurityScheme = &val
	return c
}

// SecuritySchemeEns ensures returned SecurityScheme is not nil.
func (c *ComponentsSecuritySchemesAZAZ09) SecuritySchemeEns() *SecurityScheme {
	if c.SecurityScheme == nil {
		c.SecurityScheme = new(SecurityScheme)
	}

	return c.SecurityScheme
}

// UnmarshalJSON decodes JSON.
func (c *ComponentsSecuritySchemesAZAZ09) UnmarshalJSON(data []byte) error {
	var err error

	oneOfErrors := make(map[string]error, 2)
	oneOfValid := 0

	err = json.Unmarshal(data, &c.Reference)
	if err != nil {
		oneOfErrors["Reference"] = err
		c.Reference = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &c.SecurityScheme)
	if err != nil {
		oneOfErrors["SecurityScheme"] = err
		c.SecurityScheme = nil
	} else {
		oneOfValid++
	}

	if oneOfValid != 1 {
		return fmt.Errorf("oneOf constraint failed for ComponentsSecuritySchemesAZAZ09 with %d valid results: %v", oneOfValid, oneOfErrors)
	}

	return nil
}

// MarshalJSON encodes JSON.
func (c ComponentsSecuritySchemesAZAZ09) MarshalJSON() ([]byte, error) {
	return marshalUnion(c.Reference, c.SecurityScheme)
}

// ComponentsSecuritySchemes structure is generated from "#/definitions/components->securitySchemes".
type ComponentsSecuritySchemes struct {
	MapOfComponentsSecuritySchemesAZAZ09Values map[string]ComponentsSecuritySchemesAZAZ09 `json:"-"` // Key must match pattern: `^[a-zA-Z0-9\.\-_]+$`.
}

// WithMapOfComponentsSecuritySchemesAZAZ09Values sets MapOfComponentsSecuritySchemesAZAZ09Values value.
func (c *ComponentsSecuritySchemes) WithMapOfComponentsSecuritySchemesAZAZ09Values(val map[string]ComponentsSecuritySchemesAZAZ09) *ComponentsSecuritySchemes {
	c.MapOfComponentsSecuritySchemesAZAZ09Values = val
	return c
}

// WithMapOfComponentsSecuritySchemesAZAZ09ValuesItem sets MapOfComponentsSecuritySchemesAZAZ09Values item value.
func (c *ComponentsSecuritySchemes) WithMapOfComponentsSecuritySchemesAZAZ09ValuesItem(key string, val ComponentsSecuritySchemesAZAZ09) *ComponentsSecuritySchemes {
	if c.MapOfComponentsSecuritySchemesAZAZ09Values == nil {
		c.MapOfComponentsSecuritySchemesAZAZ09Values = make(map[string]ComponentsSecuritySchemesAZAZ09, 1)
	}

	c.MapOfComponentsSecuritySchemesAZAZ09Values[key] = val

	return c
}

// UnmarshalJSON decodes JSON.
func (c *ComponentsSecuritySchemes) UnmarshalJSON(data []byte) error {
	var err error

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexAZAZ09.MatchString(key) {
			matched = true

			if c.MapOfComponentsSecuritySchemesAZAZ09Values == nil {
				c.MapOfComponentsSecuritySchemesAZAZ09Values = make(map[string]ComponentsSecuritySchemesAZAZ09, 1)
			}

			var val ComponentsSecuritySchemesAZAZ09

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			c.MapOfComponentsSecuritySchemesAZAZ09Values[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	return nil
}

// MarshalJSON encodes JSON.
func (c ComponentsSecuritySchemes) MarshalJSON() ([]byte, error) {
	return marshalUnion(c.MapOfComponentsSecuritySchemesAZAZ09Values)
}

// AsyncAPIAsyncapi is an enum type.
type AsyncAPIAsyncapi string

// AsyncAPIAsyncapi values enumeration.
const (
	Asyncapi100 = AsyncAPIAsyncapi("1.0.0")
	Asyncapi110 = AsyncAPIAsyncapi("1.1.0")
	Asyncapi120 = AsyncAPIAsyncapi("1.2.0")
)

// MarshalJSON encodes JSON.
func (i AsyncAPIAsyncapi) MarshalJSON() ([]byte, error) {
	switch i {
	case Asyncapi100:
	case Asyncapi110:
	case Asyncapi120:

	default:
		return nil, fmt.Errorf("unexpected AsyncAPIAsyncapi value: %v", i)
	}

	return json.Marshal(string(i))
}

// UnmarshalJSON decodes JSON.
func (i *AsyncAPIAsyncapi) UnmarshalJSON(data []byte) error {
	var ii string

	err := json.Unmarshal(data, &ii)
	if err != nil {
		return err
	}

	v := AsyncAPIAsyncapi(ii)

	switch v {
	case Asyncapi100:
	case Asyncapi110:
	case Asyncapi120:

	default:
		return fmt.Errorf("unexpected AsyncAPIAsyncapi value: %v", v)
	}

	*i = v

	return nil
}

// ServerScheme is an enum type.
type ServerScheme string

// ServerScheme values enumeration.
const (
	ServerSchemeKafka       = ServerScheme("kafka")
	ServerSchemeKafkaSecure = ServerScheme("kafka-secure")
	ServerSchemeAmqp        = ServerScheme("amqp")
	ServerSchemeAmqps       = ServerScheme("amqps")
	ServerSchemeMqtt        = ServerScheme("mqtt")
	ServerSchemeMqtts       = ServerScheme("mqtts")
	ServerSchemeSecureMqtt  = ServerScheme("secure-mqtt")
	ServerSchemeWs          = ServerScheme("ws")
	ServerSchemeWss         = ServerScheme("wss")
	ServerSchemeStomp       = ServerScheme("stomp")
	ServerSchemeStomps      = ServerScheme("stomps")
	ServerSchemeJms         = ServerScheme("jms")
	ServerSchemeHTTP        = ServerScheme("http")
	ServerSchemeHTTPS       = ServerScheme("https")
)

// MarshalJSON encodes JSON.
func (i ServerScheme) MarshalJSON() ([]byte, error) {
	switch i {
	case ServerSchemeKafka:
	case ServerSchemeKafkaSecure:
	case ServerSchemeAmqp:
	case ServerSchemeAmqps:
	case ServerSchemeMqtt:
	case ServerSchemeMqtts:
	case ServerSchemeSecureMqtt:
	case ServerSchemeWs:
	case ServerSchemeWss:
	case ServerSchemeStomp:
	case ServerSchemeStomps:
	case ServerSchemeJms:
	case ServerSchemeHTTP:
	case ServerSchemeHTTPS:

	default:
		return nil, fmt.Errorf("unexpected ServerScheme value: %v", i)
	}

	return json.Marshal(string(i))
}

// UnmarshalJSON decodes JSON.
func (i *ServerScheme) UnmarshalJSON(data []byte) error {
	var ii string

	err := json.Unmarshal(data, &ii)
	if err != nil {
		return err
	}

	v := ServerScheme(ii)

	switch v {
	case ServerSchemeKafka:
	case ServerSchemeKafkaSecure:
	case ServerSchemeAmqp:
	case ServerSchemeAmqps:
	case ServerSchemeMqtt:
	case ServerSchemeMqtts:
	case ServerSchemeSecureMqtt:
	case ServerSchemeWs:
	case ServerSchemeWss:
	case ServerSchemeStomp:
	case ServerSchemeStomps:
	case ServerSchemeJms:
	case ServerSchemeHTTP:
	case ServerSchemeHTTPS:

	default:
		return fmt.Errorf("unexpected ServerScheme value: %v", v)
	}

	*i = v

	return nil
}

// StreamFramingOneOf0Delimiter is an enum type.
type StreamFramingOneOf0Delimiter string

// StreamFramingOneOf0Delimiter values enumeration.
const (
	StreamFramingOneOf0DelimiterRN = StreamFramingOneOf0Delimiter(`\r\n`)
	StreamFramingOneOf0DelimiterN  = StreamFramingOneOf0Delimiter(`\n`)
)

// MarshalJSON encodes JSON.
func (i StreamFramingOneOf0Delimiter) MarshalJSON() ([]byte, error) {
	switch i {
	case StreamFramingOneOf0DelimiterRN:
	case StreamFramingOneOf0DelimiterN:

	default:
		return nil, fmt.Errorf("unexpected StreamFramingOneOf0Delimiter value: %v", i)
	}

	return json.Marshal(string(i))
}

// UnmarshalJSON decodes JSON.
func (i *StreamFramingOneOf0Delimiter) UnmarshalJSON(data []byte) error {
	var ii string

	err := json.Unmarshal(data, &ii)
	if err != nil {
		return err
	}

	v := StreamFramingOneOf0Delimiter(ii)

	switch v {
	case StreamFramingOneOf0DelimiterRN:
	case StreamFramingOneOf0DelimiterN:

	default:
		return fmt.Errorf("unexpected StreamFramingOneOf0Delimiter value: %v", v)
	}

	*i = v

	return nil
}

// APIKeyIn is an enum type.
type APIKeyIn string

// APIKeyIn values enumeration.
const (
	APIKeyInUser     = APIKeyIn("user")
	APIKeyInPassword = APIKeyIn("password")
)

// MarshalJSON encodes JSON.
func (i APIKeyIn) MarshalJSON() ([]byte, error) {
	switch i {
	case APIKeyInUser:
	case APIKeyInPassword:

	default:
		return nil, fmt.Errorf("unexpected APIKeyIn value: %v", i)
	}

	return json.Marshal(string(i))
}

// UnmarshalJSON decodes JSON.
func (i *APIKeyIn) UnmarshalJSON(data []byte) error {
	var ii string

	err := json.Unmarshal(data, &ii)
	if err != nil {
		return err
	}

	v := APIKeyIn(ii)

	switch v {
	case APIKeyInUser:
	case APIKeyInPassword:

	default:
		return fmt.Errorf("unexpected APIKeyIn value: %v", v)
	}

	*i = v

	return nil
}

// APIKeyHTTPSecuritySchemeIn is an enum type.
type APIKeyHTTPSecuritySchemeIn string

// APIKeyHTTPSecuritySchemeIn values enumeration.
const (
	APIKeyHTTPSecuritySchemeInHeader = APIKeyHTTPSecuritySchemeIn("header")
	APIKeyHTTPSecuritySchemeInQuery  = APIKeyHTTPSecuritySchemeIn("query")
	APIKeyHTTPSecuritySchemeInCookie = APIKeyHTTPSecuritySchemeIn("cookie")
)

// MarshalJSON encodes JSON.
func (i APIKeyHTTPSecuritySchemeIn) MarshalJSON() ([]byte, error) {
	switch i {
	case APIKeyHTTPSecuritySchemeInHeader:
	case APIKeyHTTPSecuritySchemeInQuery:
	case APIKeyHTTPSecuritySchemeInCookie:

	default:
		return nil, fmt.Errorf("unexpected APIKeyHTTPSecuritySchemeIn value: %v", i)
	}

	return json.Marshal(string(i))
}

// UnmarshalJSON decodes JSON.
func (i *APIKeyHTTPSecuritySchemeIn) UnmarshalJSON(data []byte) error {
	var ii string

	err := json.Unmarshal(data, &ii)
	if err != nil {
		return err
	}

	v := APIKeyHTTPSecuritySchemeIn(ii)

	switch v {
	case APIKeyHTTPSecuritySchemeInHeader:
	case APIKeyHTTPSecuritySchemeInQuery:
	case APIKeyHTTPSecuritySchemeInCookie:

	default:
		return fmt.Errorf("unexpected APIKeyHTTPSecuritySchemeIn value: %v", v)
	}

	*i = v

	return nil
}

func marshalUnion(maps ...interface{}) ([]byte, error) {
	result := []byte("{")
	isObject := true

	for _, m := range maps {
		j, err := json.Marshal(m)
		if err != nil {
			return nil, err
		}

		if string(j) == "{}" {
			continue
		}

		if string(j) == "null" {
			continue
		}

		if j[0] != '{' {
			if len(result) == 1 && (isObject || bytes.Equal(result, j)) {
				result = j
				isObject = false

				continue
			}

			return nil, errors.New("failed to union map: object expected, " + string(j) + " received")
		}

		if !isObject {
			return nil, errors.New("failed to union " + string(result) + " and " + string(j))
		}

		if len(result) > 1 {
			result[len(result)-1] = ','
		}

		result = append(result, j[1:]...)
	}

	// Close empty result.
	if isObject && len(result) == 1 {
		result = append(result, '}')
	}

	return result, nil
}

// Regular expressions for pattern properties.
var (
	regexX      = regexp.MustCompile("^x-")
	regex       = regexp.MustCompile("^[^.]")
	regexAZAZ09 = regexp.MustCompile(`^[a-zA-Z0-9\.\-_]+$`)
)
